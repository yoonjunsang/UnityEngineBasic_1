using System.Collections.Specialized;
using System.Diagnostics.SymbolStore;

namespace Operators
{
    internal class Program
    {
        public static void Main(string[] args)
        {
            int a = 14;
            int b = 6;
            int c = 0;

            //산술 연산자
            //----------------------------------------------------------------

            c = a + b; // a+b 연산 후 c 메모리(변수)에다가 결과값 (데이터)를 쓰겠다.
            Console.WriteLine(c);
            c = a - b;
            Console.WriteLine(c);
            c = a * b;
            Console.WriteLine(c);
            c = a / b; //정수끼리 나눌 때에는 몫만 반환 (소수점 버림)
            Console.WriteLine(c);
            c = a % b; // 정수를 나눈 후 나머지 연산
            Console.WriteLine(c);



            //복합 대입 연산자
            //----------------------------------------------------------------

            c += a; // c = c + a; "c에다가 a를 더해서 c에 넣겠다."
            c -= a;
            c *= a;
            c /= a;
            c %= a;


            //증감 연산자
            //-----------------------------------------------------------------
            
            //전위연산
            //연산 내용 : c=c+1;
            //반환 값 : c+1;
            ++c;
            //후위연산
            //연산 내용 : c=c+1;
            //반환 값 : c;
            c++;
            --c; // c = c - 1;, c-= 1;
            c--;

            //관계 연산자
            //두 피연산자의 관계를 비교해서 결과가 참인지 거짓인지 반환
            //----------------------------------------------------------------------------
            bool result;
            result = a == b;//a와 b가 같으면 true, 아니면 false
            result = a != b;//a와 b가 다르면 true, 아니면 false
            result = a > b;
            result = a >= b;
            result = a < b;
            result = a <= b;

            //논리 연산자
            //논리형의 피연산자들에 대해서만 연산 수행
            //----------------------------------------------------------------------------
            bool A = true;
            bool B = false;

            // or
            // A와 B  둘 중에 하나라도 true면 true, 아니면 false
            result = A | B; //Shift + 원

            // and 
            // A와 B 둘다 true 일때만 true, 아니면 false
            result = A & B;

            // xor
            // A와 B 둘중에 하나만 true면 true, 아니면 false : A가 true B가 false 또는 A가 false B가 true 일때만 true
            result = A ^ B;

            // not
            // A가 true 면 false, false면 true
            result = !A;
            result = A == false;


            // 조건부 논리연산자
            // ---------------------------------------------------

            //Conditional or
            //A가 true이면 논리연산 수행하지않고 true반환, 아니면 A|B 수행
            result = A || B;

            // Condtional and
            //A가 false 이면 논리연산 수행하지않고 false 반환, 아니면 A & B 수행
            result = A && B;


            //비트연산자
            //정수형에 대해서만 연산함
            //---------------------------------------------------
            
            //or
            Console.WriteLine(a | b);
            // a == 14 == 2^3*1 + 2^2*1 + 2^1*1 + 2^0*0 == ...00001110 (...은 0이 24개 생략된거)
            // b == 6 == 2^2*1 + 2^1*1 + 2^0*0          == ...00000110
            //--------------------or-------------------------
            //result                                    == ...00001110 == 14 (둘중 하나가 1일떄 1)


            //and
            Console.WriteLine(a & b);
            // a == 14 == 2^3*1 + 2^2*1 + 2^1*1 + 2^0*0 == ...00001110 (...은 0이 24개 생략된거)
            // b == 6 == 2^2*1 + 2^1*1 + 2^0*0          == ...00000110
            //--------------------and-------------------------
            // result                                   == ...00000110 == 6 (둘다 1일때 1)


            // xor
            Console.WriteLine(a ^ b);
            // a == 14 == 2^3*1 + 2^2*1 + 2^1*1 + 2^0*0 == ...00001110 (...은 0이 24개 생략된거)
            // b == 6 == 2^2*1 + 2^1*1 + 2^0*0          == ...00000110
            //--------------------xor-------------------------
            // result                                   == ...00001000 == 8 (둘이 1과 0일때만<다를때만> 1)


            // not
            Console.WriteLine(~a);
            // a == 14 == 2^3*1 + 2^2*1 + 2^1*1 + 2^0*0 == 00000000 00000000 00000000 00001110
            //--------------------not-------------------------
            // result                                   == 11111111 11111111 11111111 11110001 == -15 (1이면 0, 0이면 1)

            // 2의 보수 : 2진수 모든 자리 반전 후 +1 == ~a + 1
            // a == 14 == 2^3*1 + 2^2*1 + 2^1*1 + 2^0*0 == 00000000 00000000 00000000 00001110
            // -a                                          11111111 11111111 11111111 11110001 + ....1 -> 2가되니까....10 
            // -a == -14 == 2^3*1 + 2^2*1 + 2^1*1 + 2^0*0 == 11111111 11111111 11111111 11110010
            // -a * -1                                       00000000 00000000 00000000 00001101 + ...1 -> 2가 되니까...10  
            // -a * -1 == 14 = 2^3*1 + 2^2*1 + 2^1*1 + 2^0*0 == 00000000 00000000 00000000 00001110

            // 양수를 표현할 때 가장 큰 숫자       == 01111111 11111111 11111111 11111111 
            // 양수를 표현할 때 가장 큰 숫자의 음수 == 10000000 00000000 00000000 00000001

            



            // shift -left
            //비트를 n 번 왼쪽으로 밀어라
            Console.WriteLine(a << 2);
            // a == 14 == 2^3*1 + 2^2*1 + 2^1*1 + 2^0*0 == 00000000 00000000 00000000 00001110
            //-------------------<<2-----------------------
            // result                                   == 00000000 00000000 00000000 00111000 == 56

            // shift -right
            //비트를 n 번 오른쪽으로 밀어라
            Console.WriteLine(a >> 2);
            // a == 14 == 2^3*1 + 2^2*1 + 2^1*1 + 2^0*0 == 00000000 00000000 00000000 00001110
            //------------------->>2-----------------------
            // result                                   == 00000000 00000000 00000000 00000011 == 3



        }

        //bit flag mask
        // Layers
        // 0 : ground : 0번째 비트가 1
        // 1 : player : 1번째 비트가 1
        // 2 : enemy  : 2번째 비트가 1
        // 3 : prop   : 3번째 비트가 1

        // ground checking mask : 00000000 00000000 00000000 00000001
        // 어떤 객체가 감지되었을 때 땅인지 보려면
        // 해당 객체의 bit flag 값과 mask를 & 연산

        public class Collider
        {
            public int layer;
            public int collisionMask; // 00000000 00000000 00000000 00001001

            public void OnCollisionEnter(Collider other)
            {

                //enemy
                // 00000000 00000000 00000000 00000100 -> ...00000010에서 1을 왼쪽으로 1개 밀어서 ...00000100
                // 00000000 00000000 00000000 00001001
                //--------------- & ------------------
                // 00000000 00000000 00000000 00000000  : enemy랑은 충돌이 일어나지 않는다 0보다 크지않음

                //prop
                // 00000000 00000000 00000000 00001000 -> ...00000100에서 1을 왼쪽으로 1개 밀어서 ...00001000
                // 00000000 00000000 00000000 00001001
                //--------------- & ------------------
                // 00000000 00000000 00000000 00001000 : prop랑은 충돌이 일어난다. 0보다 큼

                if (((1 << other.layer) & collisionMask) > 0)
                {
                    //something to do when collision occured
                }
            }
        }



        //ref 키워드
        //파라미터를 참조 타입으로 쓰겠다는 키워드 -> 즉 여기 인자로 넣어줄 수 있는건 주소를 가지고 있는 변수 같은 메모리 영역을 넣어줘야함. (상수는 못넣어줌)
        int AfterPP(ref int variable)
        {
            int origin = variable;
            variable += 1;
            return origin;
        }

        int BeforePP(ref int variable)
        {
            variable += 1;
            return variable;
        }

    }
}